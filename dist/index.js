/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/components/character.ts":
/*!*************************************!*\
  !*** ./src/components/character.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Character\": () => (/* binding */ Character)\n/* harmony export */ });\n/* harmony import */ var _services_combat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/combat */ \"./src/services/combat.ts\");\n/* harmony import */ var _services_movement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/movement */ \"./src/services/movement.ts\");\n\n\n// 初始化游戏服务\nconst combatService = new _services_combat__WEBPACK_IMPORTED_MODULE_0__.CombatService();\nconst movementService = new _services_movement__WEBPACK_IMPORTED_MODULE_1__.MovementService();\nconst minDistanceToObstacle = 10;\nclass Character {\n    constructor(x, y, width, height, speed, maxHealth, health = maxHealth, attackPower = 10, defense = 5, isAlive = true) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.speed = speed;\n        this.maxHealth = maxHealth;\n        this.health = health;\n        this.attackPower = attackPower;\n        this.defense = defense;\n        this.isAlive = isAlive;\n    }\n    drawHealthBar(ctx, x, y, width, height, health, maxHealth) {\n        const barHeight = 10;\n        const barWidth = width;\n        const barX = x;\n        const barY = y - barHeight;\n        // 绘制背景矩形\n        ctx.fillStyle = \"#000\";\n        ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(barX, barY, barWidth, barHeight);\n        // 绘制进度条\n        const progressWidth = barWidth * (health / maxHealth);\n        ctx.fillStyle = \"#f00\";\n        ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(barX, barY, progressWidth, barHeight);\n    }\n    move(directionX, directionY, obstacles) {\n        const futureX = this.x + this.speed * directionX;\n        const futureY = this.y + this.speed * directionY;\n        if (!movementService.checkCollision({ x: futureX, y: futureY, width: this.width, height: this.height }, obstacles)) {\n            if (!movementService.checkCollision(this, obstacles)) {\n                this.x = futureX;\n                this.y = futureY;\n            }\n            else {\n                const distance = movementService.calculateDistance(this, obstacles[0]);\n                if (distance >= minDistanceToObstacle) {\n                    this.x = futureX;\n                    this.y = futureY;\n                }\n            }\n        }\n    }\n    attack(target) {\n        if (target) {\n            const isHit = combatService.attack(this, target);\n            if (isHit) {\n                target.health -= this.attackPower - target.defense;\n                if (target.health <= 0) {\n                    target.isAlive = false;\n                }\n            }\n        }\n    }\n    defend() {\n        this.defense *= 2;\n    }\n    checkCollision(character, obstacles) {\n        const futureX = character.x + character.width;\n        const futureY = character.y + character.height;\n        for (const obstacle of obstacles) {\n            if (futureX > obstacle.x && character.x < obstacle.x + obstacle.width && futureY > obstacle.y && character.y < obstacle.y + obstacle.height) {\n                return true;\n            }\n        }\n        return false;\n    }\n    calculateDistance(object1, object2) {\n        const dx = object1.x - object2.x;\n        const dy = object1.y - object2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/components/character.ts?");

/***/ }),

/***/ "./src/components/enemy.ts":
/*!*********************************!*\
  !*** ./src/components/enemy.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Enemy\": () => (/* binding */ Enemy)\n/* harmony export */ });\n/* harmony import */ var _character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character */ \"./src/components/character.ts\");\n/* harmony import */ var _services_movement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/movement */ \"./src/services/movement.ts\");\n/* harmony import */ var _utils_sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/sprite */ \"./src/utils/sprite.ts\");\n\n\n\n// 初始化游戏服务\nconst movementService = new _services_movement__WEBPACK_IMPORTED_MODULE_1__.MovementService();\nclass Enemy extends _character__WEBPACK_IMPORTED_MODULE_0__.Character {\n    constructor(x, y, width, height, speed, maxHealth, health = maxHealth, attack = 8, defense = 3, isAlive = true) {\n        super(x, y, width, height, speed, maxHealth, health, attack, defense, isAlive);\n        this.directionX = 0;\n        this.directionY = 0;\n    }\n    draw(ctx, relativePosition) {\n        const sprite = _utils_sprite__WEBPACK_IMPORTED_MODULE_2__.SPRITE_MAP.enemy;\n        const frameX = sprite.x;\n        const frameY = sprite.y;\n        const frameWidth = sprite.width;\n        const frameHeight = sprite.height;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(_utils_sprite__WEBPACK_IMPORTED_MODULE_2__.spriteSheet, frameX, frameY, frameWidth, frameHeight, this.x + relativePosition.x, this.y + relativePosition.y, this.width, this.height);\n        this.drawHealthBar(ctx, this.x + relativePosition.x, this.y + relativePosition.y + this.height + 15, this.width, 20, this.health, this.maxHealth);\n    }\n    update() {\n        // Update the enemy's position based on its direction and speed\n        this.x += this.directionX * this.speed;\n        this.y += this.directionY * this.speed;\n    }\n    setTargetPosition(targetX, targetY) {\n        // Set the enemy's direction based on its distance from the target position\n        const dx = targetX - this.x;\n        const dy = targetY - this.y;\n        const distance = Math.sqrt(dx ** 2 + dy ** 2);\n        if (distance > 0) {\n            this.directionX = dx / distance;\n            this.directionY = dy / distance;\n        }\n    }\n    updateDirection(player, obstacles) {\n        const dx = player.x - this.x;\n        const dy = player.y - this.y;\n        // Check whether the player is to the left or right of the enemy\n        if (dx < 0 && !this.isObstacleOnLeft(obstacles)) {\n            this.directionX = -1;\n        }\n        else if (dx > 0 && !this.isObstacleOnRight(obstacles)) {\n            this.directionX = 1;\n        }\n        else {\n            this.directionX = 0;\n        }\n        // Check whether the player is above or below the enemy\n        if (dy < 0 && !this.isObstacleOnTop(obstacles)) {\n            this.directionY = -1;\n        }\n        else if (dy > 0 && !this.isObstacleOnBottom(obstacles)) {\n            this.directionY = 1;\n        }\n        else {\n            this.directionY = 0;\n        }\n    }\n    isObstacleOnLeft(obstacles) {\n        return obstacles.some((obstacle) => obstacle.x + obstacle.width === this.x && obstacle.y < this.y + this.height && obstacle.y + obstacle.height > this.y);\n    }\n    isObstacleOnRight(obstacles) {\n        return obstacles.some((obstacle) => obstacle.x === this.x + this.width && obstacle.y < this.y + this.height && obstacle.y + obstacle.height > this.y);\n    }\n    isObstacleOnTop(obstacles) {\n        return obstacles.some((obstacle) => obstacle.y + obstacle.height === this.y && obstacle.x < this.x + this.width && obstacle.x + obstacle.width > this.x);\n    }\n    isObstacleOnBottom(obstacles) {\n        return obstacles.some((obstacle) => obstacle.y === this.y + this.height && obstacle.x < this.x + this.width && obstacle.x + obstacle.width > this.x);\n    }\n    findPath(start, end, obstacles) {\n        var _a, _b;\n        const openList = [new Node(start.x, start.y, 0)];\n        const closedList = [];\n        const cameFrom = new Map();\n        const gScore = new Map();\n        const fScore = new Map();\n        gScore.set(`${start.x},${start.y}`, 0);\n        fScore.set(`${start.x},${start.y}`, this.calculateDistance(start, end));\n        while (openList.length > 0) {\n            const current = openList.reduce((min, node) => { var _a, _b; return (((_b = (_a = fScore.get(`${node.x},${node.y}`)) !== null && _a !== void 0 ? _a : Infinity < fScore.get(`${min.x},${min.y}`)) !== null && _b !== void 0 ? _b : Infinity) ? node : min); }, openList[0]);\n            console.log(current);\n            if (current.x === end.x && current.y === end.y) {\n                const path = [current];\n                while (cameFrom.has(`${path[0].x},${path[0].y}`)) {\n                    path.unshift(cameFrom.get(`${path[0].x},${path[0].y}`));\n                }\n                return path;\n            }\n            openList.splice(openList.indexOf(current), 1);\n            closedList.push(current);\n            for (let dx = -1; dx <= 1; dx++) {\n                for (let dy = -1; dy <= 1; dy++) {\n                    if (dx === 0 && dy === 0) {\n                        continue;\n                    }\n                    const neighbor = new Node(current.x + dx, current.y + dy, current.cost + 1);\n                    if (movementService.checkCollision({ x: neighbor.x, y: neighbor.y, width: this.width, height: this.height }, obstacles) || closedList.some((node) => node.x === neighbor.x && node.y === neighbor.y)) {\n                        continue;\n                    }\n                    const tentativeGScore = ((_a = gScore.get(`${current.x},${current.y}`)) !== null && _a !== void 0 ? _a : Infinity) + 1;\n                    if (!openList.some((node) => node.x === neighbor.x && node.y === neighbor.y)) {\n                        openList.push(neighbor);\n                    }\n                    else if (tentativeGScore >= ((_b = gScore.get(`${neighbor.x},${neighbor.y}`)) !== null && _b !== void 0 ? _b : Infinity)) {\n                        continue;\n                    }\n                    cameFrom.set(`${neighbor.x},${neighbor.y}`, current);\n                    gScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore);\n                    fScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore + this.calculateDistance(neighbor, end));\n                }\n            }\n        }\n        return [];\n    }\n}\nclass Node {\n    constructor(x, y, cost) {\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/components/enemy.ts?");

/***/ }),

/***/ "./src/components/item.ts":
/*!********************************!*\
  !*** ./src/components/item.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Item\": () => (/* binding */ Item)\n/* harmony export */ });\nclass Item {\n    constructor(x, y, width, height, healthPoints, isConsumable, isAlive = true) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.healthPoints = healthPoints;\n        this.isConsumable = isConsumable;\n        this.isAlive = isAlive;\n    }\n    draw(ctx, relativePosition) {\n        ctx.fillStyle = \"green\";\n        ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(this.x + relativePosition.x, this.y + relativePosition.y, this.width, this.height);\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/components/item.ts?");

/***/ }),

/***/ "./src/components/player.ts":
/*!**********************************!*\
  !*** ./src/components/player.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bullet\": () => (/* binding */ Bullet),\n/* harmony export */   \"Player\": () => (/* binding */ Player)\n/* harmony export */ });\n/* harmony import */ var _character__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character */ \"./src/components/character.ts\");\n/* harmony import */ var _utils_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/sprite */ \"./src/utils/sprite.ts\");\n\n\nclass Bullet {\n    constructor(x, y, speed, directionX, directionY, size = 5) {\n        this.angle = 0;\n        this.radius = 100;\n        this.x = x;\n        this.y = y;\n        this.speed = speed;\n        this.directionX = directionX;\n        this.directionY = directionY;\n        this.size = size;\n        this.isDestroy = false;\n    }\n    draw(ctx, relativePosition, spriteSheet) {\n        const sprite = _utils_sprite__WEBPACK_IMPORTED_MODULE_1__.SPRITE_MAP.bullet;\n        const frameX = sprite.x;\n        const frameY = sprite.y;\n        const frameWidth = sprite.width;\n        const frameHeight = sprite.height;\n        ctx === null || ctx === void 0 ? void 0 : ctx.save();\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(this.x + relativePosition.x, this.y + relativePosition.y);\n        const angle = Math.atan2(this.directionY, this.directionX);\n        ctx === null || ctx === void 0 ? void 0 : ctx.rotate(Math.PI / 2 + angle);\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(spriteSheet, frameX, frameY, frameWidth, frameHeight, -this.size / 2, -this.size / 2, this.size + 10, this.size + 10);\n        ctx === null || ctx === void 0 ? void 0 : ctx.restore();\n    }\n    update(target, deltaTime) {\n        // 计算新的角度\n        const angle = this.angle + this.speed;\n        this.angle = angle;\n        const directionX = target.x + target.width / 2 - this.x;\n        const directionY = target.y + target.height / 2 - this.y;\n        const length = Math.sqrt(directionX * directionX + directionY * directionY);\n        this.directionX = directionX / length;\n        this.directionY = directionY / length;\n        console.log(this);\n        // 更新位置\n        this.x += this.speed * this.directionX * deltaTime;\n        this.y += this.speed * this.directionY * deltaTime;\n    }\n}\nclass Player extends _character__WEBPACK_IMPORTED_MODULE_0__.Character {\n    constructor(x, y, width, height, speed, maxHealth, health = maxHealth, attack = 10, defense = 5, isAlive = true) {\n        super(x, y, width, height, speed, maxHealth, health, attack, defense, isAlive);\n        this.directionX = 0;\n        this.directionY = 0;\n        this.isMoving = false;\n        this.isAttacking = true;\n        this.isDefending = false;\n        this.isInteracting = false;\n        this.bullets = [];\n        this.attackSpeed = 400;\n        this.lastShotTime = 0;\n        this.score = 0;\n        this.sword = new Bullet(x, y, 10, 0, 1, 5);\n    }\n    shoot(target) {\n        if (target) {\n            this.sword.update(target, 1);\n            const currentTime = Date.now();\n            if (currentTime - this.lastShotTime < this.attackSpeed) {\n                return;\n            }\n            const bulletSpeed = 10;\n            const bulletSize = 5;\n            const bulletX = this.x + this.width / 2 - bulletSize;\n            const bulletY = this.y + this.height / 2 - bulletSize;\n            // 计算方向向量\n            const directionX = target.x + target.width / 2 - bulletX;\n            const directionY = target.y + target.height / 2 - bulletY;\n            const length = Math.sqrt(directionX * directionX + directionY * directionY);\n            const normalizedDirectionX = directionX / length;\n            const normalizedDirectionY = directionY / length;\n            const bullet = new Bullet(bulletX, bulletY, bulletSpeed, normalizedDirectionX, normalizedDirectionY);\n            this.bullets.push(bullet);\n            this.lastShotTime = currentTime;\n        }\n    }\n    draw(ctx, relativePosition) {\n        const sprite = _utils_sprite__WEBPACK_IMPORTED_MODULE_1__.SPRITE_MAP.player;\n        const frameX = sprite.x;\n        const frameY = sprite.y;\n        const frameWidth = sprite.width;\n        const frameHeight = sprite.height;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(_utils_sprite__WEBPACK_IMPORTED_MODULE_1__.spriteSheet, frameX, frameY, frameWidth, frameHeight, this.x + relativePosition.x, this.y + relativePosition.y, this.width, this.height);\n        // 绘制子弹\n        this.bullets.forEach((bullet) => {\n            bullet.draw(ctx, relativePosition, _utils_sprite__WEBPACK_IMPORTED_MODULE_1__.spriteSheet);\n        });\n        this.sword.draw(ctx, relativePosition, _utils_sprite__WEBPACK_IMPORTED_MODULE_1__.spriteSheet);\n    }\n    findClosestEnemy(enemies) {\n        let closestEnemy = null;\n        let closestDistance = Infinity;\n        enemies.forEach((enemy) => {\n            if (enemy.isAlive) {\n                const distance = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));\n                if (distance < closestDistance) {\n                    closestEnemy = enemy;\n                    closestDistance = distance;\n                }\n            }\n        });\n        return closestEnemy;\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/components/player.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _services_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./services/system */ \"./src/services/system.ts\");\n/* harmony import */ var _services_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./services/ui */ \"./src/services/ui.ts\");\n// src/index.ts\n\n\nconst system = new _services_system__WEBPACK_IMPORTED_MODULE_0__.System();\nconst uiService = new _services_ui__WEBPACK_IMPORTED_MODULE_1__.UIService();\nsetInterval(() => {\n    if (!uiService.isPaused && !uiService.isWaitStart) {\n        system.calculate();\n    }\n    if (uiService.isRestart) {\n        system.init();\n        uiService.isRestart = false;\n    }\n    uiService.render(system.player, system.enemies, system.portal1, system.portal2);\n}, 1000 / 60);\n\n\n//# sourceURL=webpack://vampire-survivor/./src/index.ts?");

/***/ }),

/***/ "./src/services/combat.ts":
/*!********************************!*\
  !*** ./src/services/combat.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CombatService\": () => (/* binding */ CombatService)\n/* harmony export */ });\n// src/services/combat.ts\nclass CombatService {\n    constructor() { }\n    attack(attacker, defender) {\n        const hitChance = Math.random() * 100; // 命中几率，取值范围为 0 到 100\n        if (hitChance > 50) {\n            // 攻击命中\n            const damage = attacker.attackPower - defender.defense; // 计算伤害值\n            defender.health -= damage;\n            if (defender.health <= 0) {\n                defender.isAlive = false;\n            }\n            return true;\n        }\n        else {\n            // 攻击未命中\n            return false;\n        }\n    }\n    defend(defender, attacker) {\n        defender.defense *= 2;\n        this.attack(attacker, defender);\n        defender.defense /= 2;\n    }\n    interact(player, item) {\n        if (item.isConsumable) {\n            player.health += item.healthPoints;\n            if (player.health > player.maxHealth) {\n                player.health = player.maxHealth;\n            }\n            item.isAlive = false;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/services/combat.ts?");

/***/ }),

/***/ "./src/services/movement.ts":
/*!**********************************!*\
  !*** ./src/services/movement.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MovementService\": () => (/* binding */ MovementService)\n/* harmony export */ });\n/* harmony import */ var _utils_direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/direction */ \"./src/utils/direction.ts\");\n// src/services/movement.ts\n\nclass MovementService {\n    constructor() { }\n    move(character, direction) {\n        switch (direction) {\n            case _utils_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.Up:\n                character.y -= character.speed;\n                break;\n            case _utils_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.Down:\n                character.y += character.speed;\n                break;\n            case _utils_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.Left:\n                character.x -= character.speed;\n                break;\n            case _utils_direction__WEBPACK_IMPORTED_MODULE_0__.Direction.Right:\n                character.x += character.speed;\n                break;\n        }\n    }\n    checkCollision(character, obstacles) {\n        const futureX = character.x + character.width;\n        const futureY = character.y + character.height;\n        for (const obstacle of obstacles) {\n            if (futureX > obstacle.x && character.x < obstacle.x + obstacle.width && futureY > obstacle.y && character.y < obstacle.y + obstacle.height) {\n                return true;\n            }\n        }\n        return false;\n    }\n    calculateDistance(object1, object2) {\n        const dx = object1.x - object2.x;\n        const dy = object1.y - object2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/services/movement.ts?");

/***/ }),

/***/ "./src/services/system.ts":
/*!********************************!*\
  !*** ./src/services/system.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"System\": () => (/* binding */ System)\n/* harmony export */ });\n/* harmony import */ var _components_player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/player */ \"./src/components/player.ts\");\n/* harmony import */ var _components_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/enemy */ \"./src/components/enemy.ts\");\n/* harmony import */ var _components_item__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/item */ \"./src/components/item.ts\");\n/* harmony import */ var _services_movement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/movement */ \"./src/services/movement.ts\");\n\n\n\n\nclass EnemyGenerator {\n    generateEnemy(playerPosition, spawnRadius = 2000) {\n        const enemyDistance = spawnRadius + Math.random() * 100;\n        const enemyAngle = Math.random() * Math.PI * 2;\n        const spawnX = playerPosition[0] + Math.cos(enemyAngle) * enemyDistance;\n        const spawnY = playerPosition[1] + Math.sin(enemyAngle) * enemyDistance;\n        const width = 50;\n        const height = 50;\n        const speed = Math.floor(Math.random() * 2) + 1;\n        const health = Math.floor(Math.random() * 100) + 50;\n        return new _components_enemy__WEBPACK_IMPORTED_MODULE_1__.Enemy(spawnX, spawnY, width, height, speed, health);\n    }\n}\nclass System {\n    constructor() {\n        this.init();\n    }\n    calculate() {\n        // 检查是否需要生成新的敌人\n        if (this.enemies.filter((e) => e.isAlive).length < 200) {\n            const newEnemy = this.enemyGenerator.generateEnemy([this.player.x, this.player.y]);\n            this.enemies.push(newEnemy);\n        }\n        this.player.score = this.enemies.filter((e) => !e.isAlive).length;\n        // 传送门\n        if (this.movementService.checkCollision(this.portal1, [this.player])) {\n            this.player.x = this.portal2.x - 50;\n            this.player.y = this.portal2.y;\n        }\n        if (this.movementService.checkCollision(this.portal2, [this.player])) {\n            this.player.x = this.portal1.x + 50;\n            this.player.y = this.portal1.y;\n        }\n        // 处理玩家输入\n        if (this.player.isAlive) {\n            if (this.player.isMoving) {\n                this.player.move(this.player.directionX, this.player.directionY, this.obstacles);\n            }\n            if (this.player.isAttacking) {\n                const enemy = this.player.findClosestEnemy(this.enemies);\n                // player.attack(enemy, relativePosition);\n                this.player.shoot(enemy);\n            }\n            this.player.bullets = this.player.bullets.filter((bullet) => !bullet.isDestroy);\n            // 更新子弹位置\n            this.player.bullets.forEach((bullet) => {\n                bullet.x += bullet.speed * bullet.directionX;\n                bullet.y += bullet.speed * bullet.directionY;\n                // 移除超出画布范围的子弹\n                if (bullet.x < this.player.x - 1500 || bullet.y < this.player.y - 1500 || bullet.x > this.player.x + 1500 || bullet.y > this.player.y + 1500) {\n                    // player.bullets.splice(player.bullets.indexOf(bullet), 1);\n                    bullet.isDestroy = true;\n                }\n                // 检测子弹是否击中敌人\n                this.enemies.forEach((enemy) => {\n                    if (bullet.x >= enemy.x && bullet.x <= enemy.x + enemy.width && bullet.y >= enemy.y && bullet.y <= enemy.y + enemy.height) {\n                        const damage = this.player.attackPower - enemy.defense;\n                        enemy.health -= damage;\n                        // bullet.isDestroy = true;\n                        // player.bullets.splice(player.bullets.indexOf(bullet), 1);\n                        if (enemy.health <= 0) {\n                            enemy.isAlive = false;\n                        }\n                    }\n                    if (this.player.sword.x >= enemy.x && this.player.sword.x <= enemy.x + enemy.width && this.player.sword.y >= enemy.y && this.player.sword.y <= enemy.y + enemy.height) {\n                        const damage = this.player.attackPower - enemy.defense;\n                        enemy.health -= damage;\n                        // bullet.isDestroy = true;\n                        // player.bullets.splice(player.bullets.indexOf(bullet), 1);\n                        if (enemy.health <= 0) {\n                            enemy.isAlive = false;\n                        }\n                    }\n                });\n            });\n            if (this.player.isDefending) {\n                this.player.defend();\n            }\n            if (this.player.isInteracting) {\n                // 处理玩家与物品的交互\n            }\n        }\n        this.enemies.forEach((enemy) => {\n            // 处理敌人 AI\n            if (enemy.isAlive) {\n                enemy.updateDirection(this.player, this.obstacles);\n                enemy.move(enemy.directionX, enemy.directionY, this.obstacles);\n                if (Math.abs(this.player.x - enemy.x) < 30 && Math.abs(this.player.y - enemy.y) < 30) {\n                    enemy.attack(this.player);\n                }\n            }\n        });\n    }\n    init() {\n        // 初始化游戏场景和角色\n        this.player = new _components_player__WEBPACK_IMPORTED_MODULE_0__.Player(1000, 1000, 50, 50, 5, 100);\n        this.portal1 = new _components_item__WEBPACK_IMPORTED_MODULE_2__.Item(0, 150, 50, 50, 10, true);\n        this.portal2 = new _components_item__WEBPACK_IMPORTED_MODULE_2__.Item(750, 150, 50, 50, 10, true);\n        this.enemyGenerator = new EnemyGenerator();\n        this.enemies = [];\n        this.movementService = new _services_movement__WEBPACK_IMPORTED_MODULE_3__.MovementService();\n        // 初始化障碍物列表\n        this.obstacles = [];\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/services/system.ts?");

/***/ }),

/***/ "./src/services/ui.ts":
/*!****************************!*\
  !*** ./src/services/ui.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UIService\": () => (/* binding */ UIService)\n/* harmony export */ });\n/* harmony import */ var _utils_sprite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/sprite */ \"./src/utils/sprite.ts\");\n/* harmony import */ var _utils_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/canvas */ \"./src/utils/canvas.ts\");\n\n\nvar Status;\n(function (Status) {\n    Status[Status[\"PLAYING\"] = 0] = \"PLAYING\";\n    Status[Status[\"WAIT_START\"] = 1] = \"WAIT_START\";\n    Status[Status[\"PAUSED\"] = 2] = \"PAUSED\";\n    Status[Status[\"GAME_OVER\"] = 3] = \"GAME_OVER\";\n})(Status || (Status = {}));\n// 定义 UIService 类\nclass UIService extends _utils_canvas__WEBPACK_IMPORTED_MODULE_1__.CanvasUtils {\n    constructor() {\n        super(document.querySelector(\"canvas\"));\n        this.isRestart = false; // 游戏是否暂停，初始值为 true\n        this.status = Status.WAIT_START;\n        // 定义地图数组\n        this.map = [\n            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n            [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], // 地图数组的第八行\n        ];\n        this.animations = {\n            startButton: {\n                x: -70,\n                y: 70,\n                width: 180,\n                height: 180,\n                isPlay: false,\n                time: Date.now(),\n                frame: 2,\n                interval: 100,\n            },\n            stopButton: {\n                x: 0,\n                y: 0,\n                width: 180,\n                height: 180,\n                isPlay: false,\n                time: Date.now(),\n                frame: 2,\n                interval: 100,\n            },\n        };\n        this.controls = { x: 0, y: 0 };\n        const canvas = document.getElementById(\"operate-canvas\");\n        canvas.height = document.body.clientHeight;\n        canvas.width = document.body.clientWidth;\n        this.operateCanvasUtil = new _utils_canvas__WEBPACK_IMPORTED_MODULE_1__.CanvasUtils(canvas);\n        this.animations.stopButton.x += this.operateCanvasUtil.canvas.width - 180;\n        this.animations.startButton.x += this.operateCanvasUtil.canvas.width / 2;\n        this.animations.startButton.y += this.operateCanvasUtil.canvas.height / 2;\n        this.operateCanvasUtil.addEventListener(async (clickX, clickY) => {\n            Object.keys(this.animations).forEach((key) => {\n                const { x, y, width, height } = this.animations[key];\n                if (clickX >= x && clickX <= x + width && clickY >= y && clickY <= y + height) {\n                    this.animations[key].isPlay = true;\n                    this.animations[key].time = Date.now();\n                }\n            });\n        });\n        this.initJoystick(); // 初始化虚拟摇杆\n        this.handleButtonAndKeyEvent(); // 处理按钮和键盘事件\n    }\n    /**\n     * 初始化玩家的摇杆。\n     */\n    initJoystick() {\n        // 判断是否为移动设备\n        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\n        // 获取摇杆容器\n        const joystickContainer = document.querySelector(\"#joystick-container\");\n        if (isMobile) {\n            // 创建虚拟摇杆\n            const joystick = window.nipplejs.create({\n                zone: joystickContainer,\n                color: \"white\",\n                position: { left: \"50%\", top: \"50%\" },\n                size: 150,\n            });\n            // 处理虚拟摇杆的移动事件\n            joystick.on(\"move\", (event, data) => {\n                // 根据摇杆向量设置玩家移动方向\n                this.controls = {\n                    x: data.vector.x > 0 ? 1 : -1,\n                    y: data.vector.y > 0 ? -1 : 1,\n                };\n            });\n            // 处理虚拟摇杆的结束事件\n            joystick.on(\"end\", (event, data) => {\n                // 玩家停止移动\n                this.controls = {\n                    x: 0,\n                    y: 0,\n                };\n            });\n        }\n        else {\n            // 隐藏虚拟摇杆\n            joystickContainer.style.display = \"none\";\n        }\n    }\n    hiddenJoystick() {\n        // 隐藏虚拟摇杆\n        const joystickContainer = document.querySelector(\"#joystick-container\");\n        joystickContainer.style.visibility = \"hidden\";\n    }\n    showJoystick() {\n        // 显示虚拟摇杆\n        const joystickContainer = document.querySelector(\"#joystick-container\");\n        joystickContainer.style.visibility = \"visible\";\n    }\n    /**\n     * 处理玩家的按钮和键盘事件。\n     */\n    handleButtonAndKeyEvent() {\n        // // 获取暂停和重开按钮\n        // const pauseButton = document.querySelector(\"#pause-button\");\n        // const restartButton = document.querySelector(\"#restart-button\");\n        // // 获取攻击按钮\n        // const attackButton = document.querySelector(\"#attack-button\");\n        // // 处理攻击按钮的点击事件\n        // attackButton?.addEventListener(\"click\", () => {\n        //     player.isAttacking = !player.isAttacking;\n        //     attackButton.innerHTML = player.isAttacking ? \"Stop\" : \"Attack\";\n        // });\n        // pauseButton!.innerHTML = \"Start\";\n        // // 处理暂停按钮的点击事件\n        // pauseButton?.addEventListener(\"click\", () => {\n        //     this.isPaused = !this.isPaused;\n        //     pauseButton.innerHTML = this.isPaused ? \"Resume\" : \"Pause\";\n        // });\n        // // 处理重开按钮的点击事件\n        // restartButton?.addEventListener(\"click\", () => {\n        //     window.location.reload();\n        // });\n        // 处理玩家输入事件\n        document.addEventListener(\"keydown\", (event) => {\n            switch (event.code) {\n                case \"ArrowUp\":\n                    this.controls.y = -1;\n                    break;\n                case \"ArrowDown\":\n                    this.controls.y = 1;\n                    break;\n                case \"ArrowLeft\":\n                    this.controls.x = -1;\n                    break;\n                case \"ArrowRight\":\n                    this.controls.x = 1;\n                    break;\n                // case \"KeyA\":\n                //     player.isAttacking = true;\n                //     break;\n                // case \"KeyS\":\n                //     player.isDefending = true;\n                //     break;\n                // case \"KeyD\":\n                //     player.isInteracting = true;\n                //     break;\n            }\n        });\n        document.addEventListener(\"keyup\", (event) => {\n            switch (event.code) {\n                case \"ArrowUp\":\n                case \"ArrowDown\":\n                    this.controls.y = 0;\n                    break;\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                    this.controls.x = 0;\n                    break;\n                // case \"KeyA\":\n                //     player.isAttacking = false;\n                //     break;\n                // case \"KeyS\":\n                //     player.isDefending = false;\n                //     break;\n                // case \"KeyD\":\n                //     player.isInteracting = false;\n                //     break;\n            }\n        });\n    }\n    /**\n     * 显示重新开始按钮，将其样式设置为 \"display:block;\"。\n     */\n    showRestartBtn() {\n        // 获取重新开始按钮元素。\n        const restartButton = document.querySelector(\"#restart-button\");\n        // 如果重新开始按钮存在，则将其样式设置为 \"display:block;\"。\n        restartButton === null || restartButton === void 0 ? void 0 : restartButton.setAttribute(\"style\", \"display:block;\");\n    }\n    drawButton(index, position, width = 60, height = 60, text = \"Start\") {\n        let key;\n        switch (index) {\n            case 0:\n                key = 1;\n                break;\n            case 1:\n                key = 2;\n                break;\n        }\n        const button1 = _utils_sprite__WEBPACK_IMPORTED_MODULE_0__.UI_SPRITE_MAP[`button1-${key}-1`];\n        const button2 = _utils_sprite__WEBPACK_IMPORTED_MODULE_0__.UI_SPRITE_MAP[`button1-${key}-2`];\n        const button3 = _utils_sprite__WEBPACK_IMPORTED_MODULE_0__.UI_SPRITE_MAP[`button1-${key}-3`];\n        this.operateCanvasUtil.drawSprite(_utils_sprite__WEBPACK_IMPORTED_MODULE_0__.uiSpriteSheet, { sprite: button1, x: position.x + 0, y: position.y, width: width, height: height });\n        this.operateCanvasUtil.drawSprite(_utils_sprite__WEBPACK_IMPORTED_MODULE_0__.uiSpriteSheet, { sprite: button2, x: position.x + 1 * width - 4, y: position.y, width: width, height: height });\n        this.operateCanvasUtil.drawSprite(_utils_sprite__WEBPACK_IMPORTED_MODULE_0__.uiSpriteSheet, { sprite: button3, x: position.x + 2 * width - 8, y: position.y, width: width, height: height });\n        this.operateCanvasUtil.drawText(text, position.x + 45, position.y + 5, \"white\", \"bold 32px Kenney\");\n    }\n    get isPaused() {\n        return this.status === Status.PAUSED;\n    }\n    get isWaitStart() {\n        return this.status === Status.WAIT_START;\n    }\n    get isGameOver() {\n        return this.status === Status.GAME_OVER;\n    }\n    get isPlaying() {\n        return this.status === Status.PLAYING;\n    }\n    /**\n     * 渲染按钮场景\n     */\n    renderOperate() {\n        var _a, _b, _c, _d;\n        this.operateCanvasUtil.clear();\n        if (this.isPaused || this.isGameOver) {\n            // 设置透明度和颜色\n            const color = \"rgba(0, 0, 0, 0.5)\";\n            this.operateCanvasUtil.drawRect(0, 0, this.operateCanvasUtil.canvas.width, this.operateCanvasUtil.canvas.height, color);\n        }\n        if (this.isPaused || this.isPlaying) {\n            const stopButtonPosition = {\n                x: this.animations.stopButton.x,\n                y: this.animations.stopButton.y,\n            };\n            const text = this.status === Status.PLAYING ? \"Stop\" : \"Play\";\n            // 如果显示默认按钮，则绘制默认按钮\n            if (!((_b = (_a = this.animations) === null || _a === void 0 ? void 0 : _a.stopButton) === null || _b === void 0 ? void 0 : _b.isPlay)) {\n                this.drawButton(0, stopButtonPosition, 60, 60, text);\n            }\n            else {\n                const currentDate = Date.now();\n                const index = Math.ceil((currentDate - this.animations.stopButton.time) / 100);\n                if (index >= 2) {\n                    this.status = this.status === Status.PLAYING ? Status.PAUSED : Status.PLAYING;\n                    this.animations.stopButton.isPlay = false;\n                    this.drawButton(0, stopButtonPosition, 60, 60, text);\n                }\n                else {\n                    // 设置按钮坐标\n                    this.drawButton(index, stopButtonPosition, 60, 60, text);\n                }\n            }\n            return;\n        }\n        if (this.isWaitStart || this.isGameOver) {\n            const startButtonPosition = {\n                x: this.animations.startButton.x,\n                y: this.animations.startButton.y,\n            };\n            // 如果显示默认按钮，则绘制默认按钮\n            if (!((_d = (_c = this.animations) === null || _c === void 0 ? void 0 : _c.startButton) === null || _d === void 0 ? void 0 : _d.isPlay)) {\n                this.drawButton(0, startButtonPosition);\n            }\n            else {\n                const currentDate = Date.now();\n                const index = Math.ceil((currentDate - this.animations.startButton.time) / 100);\n                if (index >= 2) {\n                    this.status = Status.PLAYING;\n                    this.isRestart = true;\n                    this.animations.startButton.isPlay = false;\n                    this.drawButton(0, startButtonPosition);\n                }\n                else {\n                    // 设置按钮坐标\n                    this.drawButton(index, startButtonPosition);\n                }\n            }\n        }\n    }\n    /**\n     * 渲染游戏场景和角色。\n     */\n    render(player, enemies, portal1, portal2) {\n        if (player.health <= 0) {\n            this.status = Status.GAME_OVER;\n            this.showRestartBtn();\n        }\n        if (this.isWaitStart) {\n            this.drawImage(_utils_sprite__WEBPACK_IMPORTED_MODULE_0__.bg, 0, 0, this.canvas.width, this.canvas.height);\n        }\n        this.renderOperate();\n        if (this.isPaused || this.isWaitStart || this.isGameOver) {\n            this.hiddenJoystick();\n        }\n        if (this.isPlaying) {\n            this.showJoystick();\n            if (this.controls.x !== 0 && this.controls.y !== 0) {\n                player.directionX = this.controls.x;\n                player.directionY = this.controls.y;\n                player.isMoving = true;\n            }\n            else {\n                player.directionX = 0;\n                player.directionY = 0;\n                player.isMoving = false;\n            }\n            // 计算相对位置\n            const relativePosition = {\n                x: this.canvas.width / 2 - player.x,\n                y: this.canvas.height / 2 - player.y,\n            };\n            // 清空画布并渲染地图\n            this.clear();\n            this.renderMap(player);\n            // 绘制敌人\n            enemies.forEach((enemy) => {\n                if (enemy.isAlive) {\n                    enemy.draw(this.ctx, relativePosition);\n                }\n            });\n            // 绘制玩家\n            if (player.isAlive) {\n                player.draw(this.ctx, relativePosition);\n            }\n            // 绘制传送门\n            portal1.draw(this.ctx, relativePosition);\n            portal2.draw(this.ctx, relativePosition);\n            // 绘制计分板\n            this.drawText(`Score: ${player.score} | Health: ${player.health} | Position: (${player.x}, ${player.y})`, 10, 10, \"gray\", \"bold 32px Arial\");\n        }\n    }\n    /**\n     * 渲染游戏地图\n     * @param {Player} player - 玩家对象\n     */\n    renderMap(player) {\n        // 定义图块的大小\n        const tileSize = 200;\n        // 定义地图偏移量\n        let mapOffset = { x: 0, y: 0 };\n        // 根据玩家位置更新地图偏移量\n        mapOffset.x = -player.x % tileSize;\n        mapOffset.y = -player.y % tileSize;\n        let playerX, playerY;\n        if (player.x > 0) {\n            playerX = Math.floor(player.x / tileSize) % this.map[0].length;\n        }\n        else {\n            playerX = Math.ceil(player.x / tileSize) % this.map[0].length;\n        }\n        if (player.y > 0) {\n            playerY = Math.floor(player.y / tileSize) % this.map.length;\n        }\n        else {\n            playerY = Math.ceil(player.y / tileSize) % this.map.length;\n        }\n        // 滚动地图\n        const rowIndex = (playerX + this.map[0].length + 1) % this.map[0].length;\n        const colIndex = (playerY + this.map.length + 1) % this.map.length;\n        const rollMap = JSON.parse(JSON.stringify(this.map));\n        const middle = rollMap.splice(colIndex, rollMap.length);\n        rollMap.unshift(...middle);\n        rollMap.forEach((row) => {\n            const middle1 = row.splice(rowIndex, row.length);\n            row.unshift(...middle1);\n        });\n        // 绘制地图图块\n        for (let row = 0; row < rollMap.length; row++) {\n            for (let col = 0; col < rollMap[row].length; col++) {\n                const tile = rollMap[row][col];\n                const x = (col - 1) * tileSize + mapOffset.x;\n                const y = (row - 1) * tileSize + mapOffset.y;\n                const sprite = _utils_sprite__WEBPACK_IMPORTED_MODULE_0__.SPRITE_MAP[(\"map\" + tile)];\n                this.drawSprite(_utils_sprite__WEBPACK_IMPORTED_MODULE_0__.spriteSheet, {\n                    sprite,\n                    x,\n                    y,\n                    width: tileSize,\n                    height: tileSize,\n                });\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/services/ui.ts?");

/***/ }),

/***/ "./src/utils/canvas.ts":
/*!*****************************!*\
  !*** ./src/utils/canvas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasUtils\": () => (/* binding */ CanvasUtils)\n/* harmony export */ });\n/**\n * 画布工具类\n */\nclass CanvasUtils {\n    constructor(canvas) {\n        var _a;\n        this.listeners = [];\n        if (!canvas) {\n            throw new Error(\"Canvas not found\");\n        }\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n        const rect = canvas.getBoundingClientRect(); // 获取 Canvas 元素的位置和大小\n        // 添加点击事件监听器\n        (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.addEventListener(\"click\", async (event) => {\n            const mouseX = event.clientX - rect.left; // 计算鼠标点击位置相对于 Canvas 元素的位置\n            const mouseY = event.clientY - rect.top;\n            console.log(rect.left, rect.top, event);\n            this.listeners.forEach((listener) => {\n                listener(mouseX, mouseY);\n            });\n        });\n    }\n    /**\n     * 注册一个监听器函数，在指定类型的事件发生时会被调用。\n     * @param listener - 监听器函数\n     */\n    addEventListener(listener) {\n        this.listeners.push(listener);\n    }\n    /**\n     * 清空画布\n     */\n    clear() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n    /**\n     * 画圆形\n     * @param {number} x - 圆心横坐标\n     * @param {number} y - 圆心纵坐标\n     * @param {number} radius - 圆半径\n     * @param {string} color - 填充颜色\n     */\n    drawCircle(x, y, radius, color) {\n        this.ctx.fillStyle = color;\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, radius, 0, Math.PI * 2, true);\n        this.ctx.closePath();\n        this.ctx.fill();\n    }\n    /**\n     * 画矩形\n     * @param {number} x - 左上角横坐标\n     * @param {number} y - 左上角纵坐标\n     * @param {number} width - 矩形宽度\n     * @param {number} height - 矩形高度\n     * @param {string} color - 填充颜色\n     */\n    drawRect(x, y, width, height, color) {\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(x, y, width, height);\n    }\n    /**\n     * 画文字\n     * @param {string} text - 文字内容\n     * @param {number} x - 左上角横坐标\n     * @param {number} y - 左上角纵坐标\n     * @param {string} color - 填充颜色\n     * @param {string} font - 字体样式\n     * @param {CanvasTextAlign} textAlign - 文字水平对齐方式\n     * @param {CanvasTextBaseline} textBaseline - 文字垂直对齐方式\n     */\n    drawText(text, x, y, color = \"black\", font = \"16px\", textAlign = \"left\", textBaseline = \"top\") {\n        this.ctx.save();\n        this.ctx.textAlign = textAlign;\n        this.ctx.textBaseline = textBaseline;\n        this.ctx.fillStyle = color;\n        this.ctx.font = font;\n        this.ctx.fillText(text, x, y);\n        this.ctx.restore();\n    }\n    /**\n     * 画图片\n     * @param {HTMLImageElement} image - 图片对象\n     * @param {number} x - 左上角横坐标\n     * @param {number} y - 左上角纵坐标\n     * @param {number} width - 矩形宽度\n     * @param {number} height - 矩形高度\n     */\n    drawImage(image, x, y, width, height) {\n        this.ctx.drawImage(image, x, y, width, height);\n    }\n    /**\n     * 画精灵图\n     * @param {HTMLImageElement} image - 图片对象\n     * @param {object} params - 绘制参数\n     */\n    drawSprite(image, params) {\n        this.ctx.drawImage(image, params.sprite.x, params.sprite.y, params.sprite.width, params.sprite.height, params.x, params.y, params.width, params.height);\n    }\n    /**\n     * 设置线条宽度\n     * @param {number} width - 线条宽度\n     */\n    setLineWidth(width) {\n        this.ctx.lineWidth = width;\n    }\n    /**\n     * 画线段\n     * @param {number} x1 - 起始点横坐标\n     * @param {number} y1 - 起始点纵坐标\n     * @param {number} x2 - 结束点横坐标\n     * @param {number} y2 - 结束点纵坐标\n     * @param {string} color - 线条颜色\n     */\n    drawLine(x1, y1, x2, y2, color) {\n        this.ctx.strokeStyle = color;\n        this.ctx.beginPath();\n        this.ctx.moveTo(x1, y1);\n        this.ctx.lineTo(x2, y2);\n        this.ctx.stroke();\n    }\n    /**\n     * 画路径\n     * @param {Array<{ x: number; y: number }>} points - 点的坐标数组\n     * @param {string} color - 线条颜色\n     */\n    drawPath(points, color) {\n        this.ctx.strokeStyle = color;\n        this.ctx.beginPath();\n        this.ctx.moveTo(points[0].x, points[0].y);\n        for (let i = 1; i < points.length; i++) {\n            this.ctx.lineTo(points[i].x, points[i].y);\n        }\n        this.ctx.stroke();\n    }\n    /**\n     * 设置字体样式\n     * @param {string} font - 字体样式\n     */\n    setFont(font) {\n        this.ctx.font = font;\n    }\n    /**\n     * 设置文字水平对齐方式\n     * @param {CanvasTextAlign} align - 文字水平对齐方式\n     */\n    setTextAlign(align) {\n        this.ctx.textAlign = align;\n    }\n    /**\n     * 设置文字垂直对齐方式\n     * @param {CanvasTextBaseline} baseline - 文字垂直对齐方式\n     */\n    setTextBaseline(baseline) {\n        this.ctx.textBaseline = baseline;\n    }\n    /**\n     * 播放动画\n     * @param {Function} drawFunction - 绘制函数\n     * @param {number} startIndex - 起始索引\n     * @param {number} endIndex - 结束索引\n     * @param {number} interval - 帧间隔时间（毫秒）\n     */\n    async playAnimation(drawFunction, startIndex, endIndex, interval) {\n        for (let i = startIndex; i <= endIndex; i++) {\n            drawFunction(i);\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n    }\n}\n\n\n//# sourceURL=webpack://vampire-survivor/./src/utils/canvas.ts?");

/***/ }),

/***/ "./src/utils/direction.ts":
/*!********************************!*\
  !*** ./src/utils/direction.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Direction\": () => (/* binding */ Direction)\n/* harmony export */ });\nvar Direction;\n(function (Direction) {\n    Direction[\"Up\"] = \"up\";\n    Direction[\"Down\"] = \"down\";\n    Direction[\"Left\"] = \"left\";\n    Direction[\"Right\"] = \"right\";\n})(Direction || (Direction = {}));\n\n\n//# sourceURL=webpack://vampire-survivor/./src/utils/direction.ts?");

/***/ }),

/***/ "./src/utils/sprite.ts":
/*!*****************************!*\
  !*** ./src/utils/sprite.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SPRITE_MAP\": () => (/* binding */ SPRITE_MAP),\n/* harmony export */   \"UI_SPRITE_MAP\": () => (/* binding */ UI_SPRITE_MAP),\n/* harmony export */   \"bg\": () => (/* binding */ bg),\n/* harmony export */   \"spriteSheet\": () => (/* binding */ spriteSheet),\n/* harmony export */   \"uiSpriteSheet\": () => (/* binding */ uiSpriteSheet)\n/* harmony export */ });\nconst SPRITE_SHEET_URL = \"./assets/tilemap_packed.png\";\nconst tmpSpriteSheet = new Image();\ntmpSpriteSheet.src = SPRITE_SHEET_URL;\nconst SPRITE_MAP = {\n    enemy: { x: 0, y: 9 * 16 + 1, width: 15, height: 16 },\n    player: { x: 0, y: 8 * 16 + 1, width: 16, height: 16 },\n    bullet: { x: 8 * 16, y: 8 * 16, width: 16, height: 16 },\n    map0: { x: 0, y: 4 * 16 + 1, width: 16, height: 14 },\n    map2: { x: 1 * 16, y: 4 * 16 + 1, width: 16, height: 14 },\n    map1: { x: 2 * 16, y: 4 * 16 + 1, width: 16, height: 14 },\n};\nconst spriteSheet = tmpSpriteSheet;\nconst UI_SHEET_URL = \"./assets/UISheet.png\";\nconst tmpUISpriteSheet = new Image();\ntmpUISpriteSheet.src = UI_SHEET_URL;\nconst UI_SPRITE_MAP = {\n    \"button1-1-1\": { x: (0 + 6 * 3) * 18, y: 0 * 18, width: 16, height: 16 },\n    \"button1-1-2\": { x: (1 + 6 * 3) * 18, y: 0 * 18, width: 16, height: 16 },\n    \"button1-1-3\": { x: (2 + 6 * 3) * 18, y: 0 * 18, width: 16, height: 16 },\n    \"button1-2-1\": { x: (3 + 6 * 3) * 18, y: 0 * 18, width: 16, height: 16 },\n    \"button1-2-2\": { x: (4 + 6 * 3) * 18, y: 0 * 18, width: 16, height: 16 },\n    \"button1-2-3\": { x: (5 + 6 * 3) * 18, y: 0 * 18, width: 16, height: 16 },\n    // \"button1-3-1\": { x: (0 + 6) * 18, y: 2 * 18, width: 16, height: 16 },\n    // \"button1-3-2\": { x: (1 + 6) * 18, y: 2 * 18, width: 16, height: 16 },\n    // \"button1-3-3\": { x: (2 + 6) * 18, y: 2 * 18, width: 16, height: 16 },\n    // \"button1-4-1\": { x: (0 + 6) * 18, y: 3 * 18, width: 16, height: 16 },\n    // \"button1-4-2\": { x: (1 + 6) * 18, y: 3 * 18, width: 16, height: 16 },\n    // \"button1-4-3\": { x: (2 + 6) * 18, y: 3 * 18, width: 16, height: 16 },\n};\nconst uiSpriteSheet = tmpUISpriteSheet;\nconst BG_URL = \"./assets/backgroundColorFall.png\";\nconst tmpBg = new Image();\ntmpBg.src = BG_URL;\nconst bg = tmpBg;\n\n\n//# sourceURL=webpack://vampire-survivor/./src/utils/sprite.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;